---
title: "CPLN_Final_RB"
author: "Richard Barad"
date: "2024-04-24"
output: html_document
---

```{r setup, echo=FALSE}

library(sf)
library(tidycensus)
library(terra)
library(tidyverse)
library(tidyterra)
library(FNN)
library(gridExtra)
library(viridis)

library(caret)
library(yardstick)
library(pscl)
library(plotROC) 
library(ggrepel)
library(pROC)

palette2 <- c("#41b6c4","#253494")
palette4 <- c("#a1dab4","#41b6c4","#2c7fb8","#253494")
palette5 <- c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494")
palette10 <- c("#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4",
               "#4eb3d3","#2b8cbe","#0868ac","#084081","#f7fcf0")

```

```{r functions, echo=FALSE}

xyC <- function(aPolygonSF) {
  as.data.frame(
    cbind(x=st_coordinates(st_centroid(aPolygonSF))[,1],
          y=st_coordinates(st_centroid(aPolygonSF))[,2]))
} 

nn_function <- function(measureFrom,measureTo,k) {
  #convert the sf layers to matrices
  measureFrom_Matrix <-
    as.matrix(measureFrom)
  measureTo_Matrix <-
    as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
    output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}

quintileBreaks <- function(df,variable) {
    as.character(quantile(df[[variable]],
                          c(.01,.2,.4,.6,.8),na.rm=T))
}
```

# Get Data

## Get MSA for Atlanta

```{r atl_msa}

atl_msa <- st_read('https://arcgis.atlantaregional.com/arcgis/rest/services/OpenData/FeatureServer/67/query?outFields=*&where=1%3D1&f=geojson') %>%
  st_make_valid() %>%
  st_transform('EPSG:2240') %>%
  dplyr::filter(MSA == 'Y')

atl_msa_dissolve <- st_union(atl_msa)

```

## Get Land Cover Data

Import raster data and project it into the appropriate cordinate system. 

```{r atl_landcover}

lc2011 <- rast('DATA/lc_2011.tif')
lc2011 <- project(lc2011,'EPSG:2240')

lc2021 <- rast('DATA/lc_2021.tif')
lc2021 <- project(lc2021,'EPSG:2240')

```

# Create Fishnet for 2011

I create a 2500 x 2500 square foot grid.

```{r create_fishnet}

fishnet <- st_make_grid(atl_msa,2500) %>%
  st_sf() %>%
  st_join(.,atl_msa,predicate='intersects',left=FALSE) %>%
  mutate(ID=row_number()) %>%
  select(ID)
 
ggplot()+
  geom_sf(data=fishnet,color='grey50',fill='gray90',linewidth=0.1)+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()

```


# Reclassify Land Cover Rasters

Reclassify the land cover rasters into six categories: 'Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped'

```{r reclassify_dev, fig.width=13, fig.height=7, warning = FALSE, message = FALSE}

land_cover_reclass_matrix = matrix(
                           c(11,0,
                             21,1,
                             22,1,
                             23,1,
                             24,1,
                             41,2,
                             42,2,
                             43,2,
                             81,3,
                             82,3,
                             90,4,
                             95,4,
                             52,5,
                             71,5,
                             31,5),
                             ncol=2,byrow = TRUE)

lc2011_class <- terra::classify(lc2011,land_cover_reclass_matrix)

levels(lc2011_class) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

lc2011_class_mask <- terra::mask(lc2011_class,atl_msa)

levels(lc2011_class_mask) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

lc2021_class <- terra::classify(lc2021,land_cover_reclass_matrix)

levels(lc2021_class) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

lc2021_class_mask <- terra::mask(lc2021_class,atl_msa)

levels(lc2021_class_mask) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

grid.arrange(ncol=2,

ggplot()+
  geom_spatraster(data=lc2011_class_mask,na.rm=TRUE)+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  scale_fill_manual(values=c('lightblue','pink','lightgreen','lightyellow','blue','orange'),na.value = "transparent",name='Land Cover')+
  theme_void()+
  ggtitle('Land Cover in 2011'),

ggplot()+
  geom_spatraster(data=lc2021_class_mask,na.rm=TRUE)+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  scale_fill_manual(values=c('lightblue','pink','lightgreen','lightyellow','blue','orange'),na.value = "transparent",name='Land Cover')+
  theme_void()+
  ggtitle('Land Cover in 2021')

)

```

Calculate the percent of each grid square that is developed in 2011 and 2021.

```{r land_cover_percent_developed, fig.width=10, fig.height=5}

lc2011_extract <- terra::extract(lc2011_class,fishnet,fun=table) %>%
  mutate(pct_developed = Developed / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100)

lc2021_extract <- terra::extract(lc2021_class,fishnet,fun=table) %>%
  mutate(pct_developed2021 = Developed / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100)

fishnet_pct_developed <- cbind(fishnet,lc2011_extract %>% select(pct_developed),lc2021_extract %>% select(pct_developed2021)) %>%
  mutate(change = pct_developed2021 - pct_developed)

grid.arrange(ncol=2,

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=pct_developed),color='transparent')+
  scale_fill_viridis(option='rocket',name='Percent Developed')+
  geom_sf(data=atl_msa,fill='transparent',color='white',linewidth=0.5)+
  theme_void()+
  ggtitle('Percent Developed in 2011'),

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=pct_developed2021),color='transparent')+
  scale_fill_viridis(option='rocket',name='Percent Developed')+
  geom_sf(data=atl_msa,fill='transparent',color='white',linewidth=0.5)+
  theme_void()+
  ggtitle('Percent Developed in 2021')
)
  
```

Determine grid squares that were developed in 2011 and 2021. For this analysis, consider any grid square that is more tha 25% developed to be developed.

``` {r identify_developed, fig.width=13, fig.height=7}

fishnet_pct_developed <- fishnet_pct_developed %>%
  mutate(developed2011 = as.factor(ifelse(pct_developed > 25,1,0)),
         developed2021 = as.factor(ifelse(pct_developed2021 > 25,1,0)),
         lc_change = as.factor(ifelse(developed2011 == 0 & developed2021 == 1 & change > 5,1,0)))

grid.arrange(ncol=3,

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=developed2011),color='transparent')+
  scale_fill_manual(values=c('gray95','pink'),labels=c('Not Developed','Developed'),name='')+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()+
  ggtitle('Developed Pixels in 2011'),

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=developed2021),color='transparent')+
  scale_fill_manual(values=c('gray95','pink'),labels=c('Not Developed','Developed'),name='')+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()+
  ggtitle('Developed Pixels in 2021'),

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=lc_change),color='transparent')+
  scale_fill_manual(values=c('gray95','green'),labels=c('No Change','Change'),name='')+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()+
  ggtitle('Pixels with a Change in Development')
)

```

Determine the dominant land cover class in each grid square and also determine the percent of pixels in each grid square that are forest, farm, wetlands, and other. This was done so that we can test using both boolean and continuous variables for landcover in the model. 

```{r}

fishnet_2011 <- cbind(lc2011_extract,fishnet_pct_developed %>% select(developed2011,lc_change)) %>%
  rename(developed = developed2011) %>%
  rowwise() %>% mutate(max = max(c(Forest,Farm,Wetlands,Water,OtherUndeveloped,Developed))) %>%
  ungroup() %>%
  st_as_sf() %>%
  mutate(water=as.factor(ifelse(max==Water,1,0)),
         forest=as.factor(ifelse(max==Forest,1,0)),
         farm=as.factor(ifelse(max==Farm,1,0)),
         wetlands=as.factor(ifelse(max==Wetlands,1,0)),
         otherundeveloped=as.factor(ifelse(max==OtherUndeveloped,1,0)),
         pct_forest = Forest / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_farm = Farm / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_wetlands = Wetlands / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_other = OtherUndeveloped / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100) %>%
  select(ID,water,forest,farm,wetlands,otherundeveloped,lc_change,developed,pct_forest,pct_farm,pct_wetlands,pct_other,geometry)

```

## Spatial Lag of Development

I did spatial Lag to nearest 5 developed grid squares and 10 developed grid squares so that we can test models using both. 

``` {r}

fishnet_2011$lagDevelopment_5 <- nn_function(xyC(fishnet_2011),xyC(filter(fishnet_2011,developed==1)),5)
fishnet_2011$lagDevelopment_10 <- nn_function(xyC(fishnet_2011),xyC(filter(fishnet_2011,developed==1)),10)

ggplot()+
  geom_sf(data=fishnet_2011,aes(fill=lagDevelopment_10),color='transparent')+
  geom_sf(data=atl_msa,color='black',linewidth=0.5,fill='transparent')+
  scale_fill_viridis_c(option='virdis',name='Spatial Lag to Development (feet)')+
  labs(title = "Spatial Lag to 2011 Development")+
  theme_void()

```


## 2.4. Census Data

```{r load_key, warning = FALSE, eval = FALSE}
census_api_key("ab9309f9cc70c0e1895e7166c3ca981c40cf0331", overwrite = TRUE , install = TRUE)
```


```{r, warning = FALSE, message = FALSE, results = "hide"}
atlantaPop11 <- 
  get_acs(geography = "tract", variables = "B01003_001", year = 2011,
                state = 13, geometry = TRUE, 
                county=c("Fayette","Carroll","Rockdale","Cobb","Forsyth",
                         "Clayton","Henry","Dawson","Bartow","Lamar","Haralson","Meriwether","Newton","Gwinnett","Fulton","Pickens","Spalding","Douglas","Coweta","Heard","Butts","Jasper","DeKalb", "Cherokee","Walton","Pike","Barrow","Paulding")) %>%
  rename(pop_2011 = estimate) %>%
  st_transform(st_crs(atl_msa))

atlantaPop21 <- 
  get_acs(geography = "tract", variables = "B01003_001", year = 2021,
                state = 13, geometry = TRUE, 
                county=c("Fayette","Carroll","Rockdale","Cobb","Forsyth",
                         "Clayton","Henry","Dawson","Bartow","Lamar","Haralson","Meriwether","Newton","Gwinnett","Fulton","Pickens","Spalding","Douglas","Coweta","Heard","Butts","Jasper","DeKalb", "Cherokee","Walton","Pike","Barrow","Paulding")) %>%
  rename(pop_2021 = estimate) %>%
  st_transform(st_crs(atl_msa)) %>%
  st_buffer(-1)
```


# 2011 and 2021 census data plot

```{r, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
grid.arrange(
ggplot() +
  geom_sf(data = atlantaPop11, aes(fill=pop_2011), colour=NA) +
  scale_fill_viridis(option='rocket',name='Population 2011',direction=-1)+
  labs(title="Population, Atlanta MSA: 2011") +
  theme_void(),

ggplot() +
  geom_sf(data = atlantaPop21, aes(fill=pop_2021), colour=NA) +
  scale_fill_viridis(option='rocket',name='Population 2021',direction=-1)+
  labs(title="Population, Atlanta MSA: 2021") +
  theme_void(), ncol=2)
```


# Assigns a proportion of a tract’s population to a grid cell weighted by the proportion of the tract that intersects the grid cell

```{r, warning = FALSE, message = FALSE}

fishnet_2011 <-
  st_interpolate_aw(atlantaPop11["pop_2011"], fishnet_2011, extensive=TRUE) %>%
  st_drop_geometry() %>%
  rownames_to_column(var = "ID") %>%
  left_join(fishnet_2011 %>%
              mutate(ID = as.character(ID)),.,
            by=c('ID'='ID')) %>% 
  mutate(pop = replace_na(pop_2011,0))

```

## Calculate Distance from Road to Fishnet Centroid

``` {r}

highways <- st_read('./Data/atlanta_highway.geojson') %>% st_transform('EPSG:2240')

centroid <- fishnet_2011 %>%
  st_centroid()

nearest_feat <- st_nearest_feature(centroid,highways)

fishnet_2011$highway_dist <- as.double(st_distance(centroid, highways[nearest_feat,], by_element=TRUE))

ggplot()+
  geom_sf(data=fishnet_2011,aes(fill=highway_dist),color='transparent')+
  scale_fill_viridis_c(name='Distance to Highway feet')+
  geom_sf(data=highways,color='red')+
  theme_void()

```

## Join Counties

``` {r}

fishnet_2011 <- st_join(fishnet_2011,atl_msa %>% rename (county = NAME10) %>% select(county),largest=TRUE) %>%
  filter(water == 0) 
  
```
# Data Exploration

# Modelling

# Build Fishnet for 2021

## Identify Dominant Land Cover Class 

```{r}

fishnet_2021 <- cbind(lc2021_extract,fishnet_pct_developed %>% select(developed2021)) %>%
  rename(developed = developed2021) %>%
  rowwise() %>% mutate(max = max(c(Forest,Farm,Wetlands,Water,OtherUndeveloped))) %>%
  ungroup() %>%
  mutate(water=as.factor(ifelse(max==Water,1,0)),
         forest=as.factor(ifelse(max==Forest,1,0)),
         farm=as.factor(ifelse(max==Farm,1,0)),
         wetlands=as.factor(ifelse(max==Wetlands,1,0)),
         otherundeveloped=as.factor(ifelse(max==OtherUndeveloped,1,0)),
         pct_forest = Forest / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_farm = Farm / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_wetlands = Wetlands / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_other = OtherUndeveloped / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100) %>%
  select(ID,water,forest,farm,wetlands,otherundeveloped,developed,pct_forest,pct_farm,pct_wetlands,pct_other,geometry) %>%
  st_as_sf()

```


## Spatial Lag of Development and Road Distance

``` {r}

fishnet_2021$lagDevelopment_5 <- nn_function(xyC(fishnet_2021),xyC(filter(fishnet_2021,developed==1)),5)
fishnet_2021$lagDevelopment_10 <- nn_function(xyC(fishnet_2021),xyC(filter(fishnet_2021,developed==1)),10)

fishnet_2021$highway_dist <- as.double(st_distance(centroid, highways[nearest_feat,], by_element=TRUE))

```

## Add Population

```{r}

fishnet_2021 <-
  st_interpolate_aw(atlantaPop21["pop_2021"], fishnet_2021, extensive=TRUE) %>%
  st_drop_geometry() %>%
  rownames_to_column(var = "ID") %>%
  left_join(fishnet_2021 %>%
              mutate(ID = as.character(ID)),
            ., by=c("ID"='ID')) %>% 
  mutate(pop = replace_na(pop_2021,0))

```

## Join Counties

``` {r}

fishnet_2021 <- st_join(fishnet_2021,atl_msa %>% rename (county = NAME10) %>% select(county),largest=TRUE) %>%
  filter(water == 0) 
  
```


# 4. Predicting for 2010

In this section, six separate logistic regression models are estimated to predict development change between 2001 and 2011 - with each subsequent model more sophisticated then the last. To do so, the data is split into 50% training/test sets. Models are estimated on the training set.

Normally, as in previous chapters, a results table row would be generated for each model describing the accuracy and generalizability of predictions for each specification. For brevity, a less sophisticated approach is taken here, judging each by the McFadden or “Psuedo” R Squared statistic on the test set. The model with the greatest goodness of fit is then used for the purposes of prediction.

## 4.2. Modeling

First, `dat` is split into training and test sets. Note how imbalanced the panel is with `table(datTrain$lc_change1)`.

```{r, warning = FALSE, message = FALSE}
set.seed(3456)
trainIndex <- 
  createDataPartition(dat$developed, p = .50,
                                  list = FALSE,
                                  times = 1)
datTrain <- dat[ trainIndex,]
datTest  <- dat[-trainIndex,]

nrow(dat)
```

Next six separate `glm` models are estimated adding new variables for each. Figure 4.1 shows the Psuedo R-Squared associated with each model.

`Model1` includes only the 2001 land cover types. `Model2` adds the `lagDevelopment`. Models 3, 4 and 5 attempt three different approaches for modeling population change. `Model3` uses population in 2000; `Model4` uses 2000 and 2010 population; and `Model5` uses population change. All are significant so which population feature should be chosen? The answer lies in how the model will be used to forecast. By modeling population change between 2000 and 2010, the model is well specified to forecast 2020 development by having `pop_Change` indicate change between 2010 and 2020. `Model6` includes distance to the highways, and is the final model employed for prediction.

```{r, warning = FALSE, message = FALSE}
Model1 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped, 
              family="binomial"(link="logit"), data = datTrain)

Model2 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment, 
              family="binomial"(link="logit"), data = datTrain)
              
Model3 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_2000, 
              family="binomial"(link="logit"), data = datTrain)          
              
Model4 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_2000 + 
              pop_2010, 
              family="binomial"(link="logit"), data = datTrain)              
            
Model5 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change, 
              family="binomial"(link="logit"), data = datTrain)              
              
Model6 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change + 
              distance_highways, 
              family="binomial"(link="logit"), data = datTrain) 
```

Working carefully through the below code block, a very concise approach for creating a data frame of psudeo R Squares for each model and plotting them for comparison. Recall, `pR2` is the function for psuedo R squared. Dissect the line that uses the `map_dfc` function to see how this approach loops through the models retrieving the goodness of fit for each.

```{r, warning = FALSE, message = FALSE}
modelList <- paste0("Model", 1:6)
map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("Model",1:6)) %>%
  gather(Model,McFadden) %>%
  ggplot(aes(Model,McFadden)) +
    geom_bar(stat="identity") +
    labs(title= "McFadden R-Squared by Model") +
    plotTheme
```

Next, a data frame is created that includes columns for the observed development change, `lc_change`, and one that includes predicted probabilities for `Model6`. This data frame is then used as an input to a density plot visualizing the distribution of predicted probabilities by observed class. Only a small number of predicted probabilities are greater than or equal to 50% `(nrow(filter(testSetProbs, probs >= .50)) / nrow(datTest))`. This makes good sense, given how rare of an event development is in our dataset. Ultimately, in order to judge our model with a confusion matrix, a smaller development classification threshold must be employed.

```{r, warning = FALSE, message = FALSE}
testSetProbs <- 
  data.frame(class = datTest$lc_change,
             probs = predict(Model6, datTest, type="response")) 
  
ggplot(testSetProbs, aes(probs)) +
  geom_density(aes(fill=class), alpha=0.5) +
  scale_fill_manual(values = palette2,
                    labels=c("No Change","New Development")) +
  labs(title = "Histogram of test set predicted probabilities",
       x="Predicted Probabilities",y="Density") +
  plotTheme
```

# Predict on 2021 Fishnet